diff --git a/kalloc.c b/kalloc.c
index 14cd4f4..7b514be 100644
--- a/kalloc.c
+++ b/kalloc.c
@@ -8,19 +8,20 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "spinlock.h"
+#include "freelist.h"
 
 void freerange(void *vstart, void *vend);
 extern char end[]; // first address after kernel loaded from ELF file
                    // defined by the kernel linker script in kernel.ld
 
-struct run {
-  struct run *next;
-};
+// struct run {
+//   struct run *next;
+// };
 
 struct {
   struct spinlock lock;
   int use_lock;
-  struct run *freelist;
+  Queue freelist;
 } kmem;
 
 // Initialization happens in two phases.
@@ -33,6 +34,8 @@ kinit1(void *vstart, void *vend)
 {
   initlock(&kmem.lock, "kmem");
   kmem.use_lock = 0;
+  kmem.freelist.start = NULL_QUEUE;
+  kmem.freelist.end = NULL_QUEUE;
   freerange(vstart, vend);
 }
 
@@ -59,7 +62,7 @@ freerange(void *vstart, void *vend)
 void
 kfree(char *v)
 {
-  struct run *r;
+  struct queueNode *Q;
 
   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
     panic("kfree");
@@ -69,9 +72,18 @@ kfree(char *v)
 
   if(kmem.use_lock)
     acquire(&kmem.lock);
-  r = (struct run*)v;
-  r->next = kmem.freelist;
-  kmem.freelist = r;
+  Q = (queueNode*) v;
+  Q->nextSlot = NULL_QUEUE;
+
+  if ((kmem.freelist.start == NULL_QUEUE) && (kmem.freelist.end == NULL_QUEUE)) {
+    kmem.freelist.start = Q;
+    kmem.freelist.end = Q;
+  }
+  else {
+    (kmem.freelist.end)->nextSlot = Q;
+    kmem.freelist.end = Q;
+  }
+
   if(kmem.use_lock)
     release(&kmem.lock);
 }
@@ -82,15 +94,20 @@ kfree(char *v)
 char*
 kalloc(void)
 {
-  struct run *r;
+  struct queueNode *Q;
 
   if(kmem.use_lock)
     acquire(&kmem.lock);
-  r = kmem.freelist;
-  if(r)
-    kmem.freelist = r->next;
+  Q = kmem.freelist.start;
+  if(Q){
+    if (kmem.freelist.start == kmem.freelist.end) {
+      kmem.freelist.end = NULL_QUEUE;
+    }
+    kmem.freelist.start = Q->nextSlot;
+    Q->nextSlot = NULL_QUEUE;
+  }
   if(kmem.use_lock)
     release(&kmem.lock);
-  return (char*)r;
+  return (char*)Q;
 }
 
